using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro;
using Unity.VisualScripting;

public class PlaneController : MonoBehaviour
{
    [Header("Flying Obj Stats")]
    [Tooltip("How much the speed ramps up or down")]
    public float throttleIncriment = 0.1f;
    [Tooltip("Maximum speed of the object")]
    public float maxThrust = 200f;
    [Tooltip("How responsive the object is to directional movement")]
    public float responsiveness = 100f;
    [Tooltip("Lift generated by the object dependant on it's speed")]
    public float lift = 135f;

    [SerializeField] Animator animator;
    public GameObject bellyObj;
    public GameObject altimeterObj;
    public LayerMask terrainLayer;


    private bool isGrounded;
    private float throttle;
    private float yaw;
    private float pitch;
    private float roll;

    int currentAlt;
    int currentSpeed;
    int currentThrottle;


    float rollAmount;
    float pitchAmount;

    private float responseModifier
    {
        get
        {
            return (rb.mass / 10f) * responsiveness;
        }
    }

    Rigidbody rb;
    [SerializeField] TextMeshProUGUI hud;

    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        PlatformController.singleton.Init("COM3", 115200);
    }

    private void InputHandling()
    {
        // Set Rotational values from out inputs
        if (Input.GetKeyDown(KeyCode.Space))
        {
            if (animator.GetBool("isFlying") && currentAlt <= 6 && currentThrottle == 0)
            {
                animator.SetBool("isFlying", false);
                animator.SetBool("isFlapping", false);
            }
            else
            {
                animator.SetBool("isFlying", true);
                animator.SetBool("isFlapping", true);
            }
        }
        if (animator.GetBool("isFlying"))
        {
            if (Input.GetKey(KeyCode.LeftAlt)) throttle += throttleIncriment;
            else if (Input.GetKey(KeyCode.LeftControl)) throttle -= throttleIncriment;
        }

        yaw = Input.GetAxis("Yaw");
        pitch = Input.GetAxis("Pitch");
        roll = Input.GetAxis("Roll");

        throttle = Mathf.Clamp(throttle, 0f, 100f);
    }

    private void Update()
    {
        InputHandling();
        UpdateHUD();
        rollAmount = Mathf.DeltaAngle(transform.eulerAngles.z, 0);
        pitchAmount = -Mathf.DeltaAngle(transform.eulerAngles.x, 0);
        print("Roll: " + rollAmount);
        print("Pitch: " + pitchAmount);
        PlatformController.singleton.Roll = PlatformController.singleton.MapRange(rollAmount, -45, 45, -10, 10);
        PlatformController.singleton.Pitch = PlatformController.singleton.MapRange(-pitchAmount, -55, 55, -10, 10);
    }

    private void FixedUpdate()
    {
        //float rollAmount = Mathf.DeltaAngle(transform.eulerAngles.z, 0);
        //float pitchAmount = -Mathf.DeltaAngle(transform.eulerAngles.x, 0);
        // Apply Forces
        //PlatformController.singleton.Roll = PlatformController.singleton.MapRange(rollAmount,-40,40,-10,10);
        //PlatformController.singleton.Pitch = PlatformController.singleton.MapRange(-pitchAmount,-40,40,-10,10);
        
        if (animator.GetBool("isFlying"))
        {
            rb.AddForce(transform.forward * maxThrust * throttle);
            rb.AddTorque(transform.up * yaw * responsiveness);
            if (pitch > 0 && pitchAmount < 40)
            {
                rb.AddTorque(transform.right * pitch * responsiveness);
            }
            else if (pitch < 0 && pitchAmount > -40)
            {
                rb.AddTorque(transform.right * pitch * responsiveness);
            }
            if (roll > 0 && rollAmount < 30)
            {
                rb.AddTorque(-transform.forward * roll * responsiveness);
            }
            else if (roll < 0 && rollAmount > -30)
            {
                rb.AddTorque(-transform.forward * roll * responsiveness);
            }

            rb.AddForce(Vector3.up * rb.velocity.magnitude * lift);
        }
    }

    private void UpdateHUD()
    {
        currentThrottle = (int)throttle;
        currentSpeed = (int)(rb.velocity.magnitude * 3.6f);
        RaycastHit hit;
        if (Physics.Raycast(transform.position, Vector3.down, out hit, Mathf.Infinity, terrainLayer))
        {
            currentAlt = (int)(altimeterObj.transform.position - hit.point).magnitude;
        }

        hud.text = "Throttle: " + currentThrottle + "\n";
        hud.text += "Airspeed: " + currentSpeed + " km/h\n";
        hud.text += "Altitude: " + currentAlt;
    }
}
